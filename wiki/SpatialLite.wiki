#summary geospatially enabled version of sqlite

=Overview=
[http://http://www.gaia-gis.it/spatialite/ SpatiaLite] is an extension implementing OpenGIS on a SQLite database.

==Programmatically Invoking SpatiaLite==
SQLite supports the ability to load external extensions via 'load_extension'. You can construct an SQL statement 'SELECT load_extension("libspatialite-2.dll")' to invoke the SpatiaLite extension. By default, however, 'load_extension' is disabled in SQLite, you need to be able to call the C API routine 'sqlite3_enable_load_extension' to enable it.
When grabbing the code make sure you get the latest version, currently it is v2.2. There was an issue of negative values not being handled in previous versions, so I spent a day wondering why I could get nothing to work.

==Perl==
The downside I found is the DBI driver for SQLite in Perl does not support load_extension, nor does it have an interface to call the C routine 'sqlite3_enable_load_extension' which enables the ability to use 'load_extension'. So in short, there does not appear to be a way to use SpatiaLite via the DBD:SQLite driver in Perl. There are other SQLite DB interfaces in Perl, so one of those may have this ability.
==Python==
The pysqlite module for Python, does in fact support the 'load_extension' ability.
Here is a sample to get it up and running, this is on my windows machine(note the DLLs reside in the same directory as the script):
{{{
  from pysqlite2 import dbapi2 as sqlite

  DB = sqlite.connect( './html_content.db' )
  DB.enable_load_extension(True)
  DB.execute( 'SELECT load_extension("libspatialite-2.dll")' )
  DBCursor = DB.cursor()
}}}

My database was a fairly simple using WKT geometry. Whole trying to determine why nothing would work, which in the end was due to old DLLs, I played around with testing to see if my WKT_geometry column was valid. It was a simple POINT( x y ) data set. Here is a quick query to find out what the SpatiaLite sees:
{{{
strSQL = 'SELECT GeometryType( GeomFromText(wkt_geometry) ) FROM html_content'
}}}
Here is a SQL statement to find a point inside a polygon(Note the double parenthesis around the 'POLYGON'):
{{{
strSQL = 'SELECT wkt_geometry,platform_handle FROM html_content 
          WHERE Contains( GeomFromText( \'POLYGON((-79.22 32.36,-78.97 32.36,-78.97                
                32.63,-79.22 32.63,-79.22 32.36))\'), GeomFromText(wkt_geometry) )'

        DBCursor.execute( strSQL )
        for row in DBCursor:
            print( row[0] + ' ' + row[1] )
}}}

==Xenia Database Query==
Your database doesn't have to be constructed using WKB or WKT columns. Playing around with the Xenia database to get platforms only in the Carolinas RCOOS region, I cobbled together this query that runs against the Xenia DB:
{{{
SELECT platform_handle, description, fixed_longitude, fixed_latitude,url 
FROM platform 
WHERE active = 1 AND
Contains( GeomFromText( 'POLYGON((-82 31.65, -82 32.5, -74 37.5, -74 31.65, -82 31.65))'), GeomFromText( 'POINT(' || fixed_longitude || ' ' || fixed_latitude ||')' ) )
ORDER BY platform_handle ASC
}}}

The area of interested is the 2nd GeomFromText, that's where I build the WKT POINT() from the existing longitude and latitude columns. Those columns are in  decimal degrees, but to use GeomFromText we need to build POINT( longitude, latitude ). So after some searching in teh SQL docs I see I can build the string on the fly using the concatenate "||" and roll my own WKT string.