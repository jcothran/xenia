#summary Optimization notes for Sqlite, SQL statements

= Data Dictionary Listing(Simple Scalar Types) = 

{{{
-- scalar data dictionary listing for simple scalar obs (standard listing)
-- Xenia version 3
-- select t0.row_id,t2.standard_name,t3.standard_name from m_type t0,m_scalar_type t1,obs_type t2,uom_type t3 where t0.m_scalar_type_id = t1.row_id and t0.num_types = 1 and t1.obs_type_id = t2.row_id and t1.uom_type_id = t3.row_id;

-- Xenia version 2
-- select t1.row_id,t2.standard_name,t3.standard_name from m_type t1,obs_type t2,uom_type t3 where t1.obs_type_id = t2.row_id and t1.uom_type_id = t3.row_id;
}}}

= Adding simple scalar types to the data dictionary tables and processing scripts = 

The below example shows how to add a simple scalar data type (a vector of only one component) to the data dictionary.  The particular observation type is 'depth' and the unit of measurement is meters 'm'

For the tables involved, the row_id on each of the tables is defined as the primary key so they will autoincrement on inserts to the next available row_id.

For further examples see the initial data dictionary population script at http://code.google.com/p/xenia/source/browse/trunk/sqlite/sql/obs.sql

----

Add observation type row to obs_type table.  Note that the naming convention is all lower 
case with underscore character as a space/word separator.
`INSERT INTO obs_type(standard_name,definition) VALUES ('depth', 'approximate water depth');`

Check the row_id of the newly inserted row for reference in later step

obs_type.row_id = 42

----

Add unit of measurement type row to uom_type table.  Note that the naming convention is all lower case with underscore character as a space/word separator.

For this example the uom_type row (meter) already exists on the database so we do not perform the below step, but the below line shows how we would add this row.

`INSERT INTO uom_type(standard_name,definition,display) VALUES ('m', 'meter', 'm');`

Check the row_id of the newly inserted row for reference in later step

uom_type.row_id = 6

----

*Note* if using Xenia version 2 database the below INSERT statement will be against the m_type table and not the m_scalar_type

Add row to m_scalar_type table to associate the obs_type with its uom - note the referenced row_id's used from the previous 2 steps

`INSERT INTO m_scalar_type(obs_type_id,uom_type_id) VALUES (42,6);`

Check the row_id of the newly inserted row for reference in later step

m_scalar_type.row_id = 48

----

*Note* step Xenia version 3 only

Add row to m_type table to associate the m_type.row_id=m_type_id to the m_scalar_type.row_id  The inserted '1' value lets us know that there is only one component to this vector

`INSERT INTO m_type (num_types,m_scalar_type_id) VALUES (1,48);`

m_type.row_id = 44

----

Add or update rows on m_type_display_order which correspond to the display order of observation types for certain products(air,surface,water,etc) - if the order is unimportant, just insert the m_type_id the last row of the table.

----

associated scripts for new observation types

http://code.google.com/p/xenia/source/browse/trunk/sqlite/import_export/obskml_to_xenia_sqlite.pl script, function get_m_type_id allows for creating synonym terms to also recognize the available data

graph.xml used by http://code.google.com/p/xenia/source/browse/#svn/trunk/sqlite/time_series and http://code.google.com/p/xenia/source/browse/#svn/trunk/obskml/products/html_tables

style.xml used by http://code.google.com/p/xenia/source/browse/#svn/trunk/obskml/products/gearth

= datetime formatting example for time comparison statements =

see http://www.sqlite.org/cvstrac/wiki?p=DateAndTimeFunctions

`multi_obs.m_date <= strftime('%Y-%m-%dT%H:00:00','2008-09-24T14:00:00','+1 hour')`

Note that function datetime by default returns a space separated result which will only compare the date portion against the ISO8601 'T' separated multi_obs.m_date field.  The above comparison avoids that date only comparison error.

Note to use strftime, datetime, etc on single values or small subsets as they add much time cost to queries.  

= use UNION instead of JOIN/OR = 

from experimentation it seems JOINS and OR statements may not correctly use/invoke indexes and it may be faster to do a UNION of two separate SELECT statements which are making use of table indexes

= dumping a table select as insert statements = 

http://www.sqlite.org/sqlite.html

Below commands will dump the table select on table platform to the text file 'test.sql' as insert statements

{{{
sqlite> .output test.sql
sqlite> .mode insert platform
sqlite> select * from platform;
sqlite> .quit
}}}