      #Range Tests

= Overview = 
For data stored in a [http://code.google.com/p/xenia/wiki/XeniaPackageV2 Xenia] schema database, the [http://code.google.com/p/xenia/source/browse/trunk/postgresql/qaqc/rangetests/rangeCheck.py rangeTest.py] script will test observations to determine if they fall within defined limits. The script will then populate the qc_level and qc_flag columns in the multi_obs table.
= Scripts =
  == rangeTests.py ==  
  === Input ===
    * Command Line Parameters
    The script uses an XMLConfigFile for its various configurations. The full path to the xml config file must be given as a command line argument. 
    For example: rangeTests.py "path\to\XMLConfigFile.xml"
    [Here ] is a sample config file.

   * XML Configuration File
   {{{
<environment>
  <database>
    <db>
      <type></type>
      <name></name>
      <user></user>
      <pwd></pwd>
      <host></host>
    </db>
    <sqlQCUpdateFile></sqlQCUpdateFile>
  </database>
  <qcLimits>
    <fileType></fileType>
    <file></file>
  </qcLimits>
  <unitsCoversion>
    <file></file>
  </unitsCoversion>
  <logging>    
    <logMsgs></logMsgs>
    <maxBytes></maxBytes>
    <backupCount></backupCount>       
    <logDir></logDir>
  </logging> 
  <outputs>
    <qcResultsTable></qcResultsTable>
  </outputs>
</environment>

   }}}
   * `<environment>`
      * `<database>` 
        * `<db>`
          * `<type>` defines the type of database engine the Xenia database is hosted on. Can be either, sqlite or postgres currently.
          * `<name>` for a SQLite database, this is the path to the database file. For !PostGres this is the database name to connect to.
          * `<user>` is not used in SQLite. For !PostGres, this is the user name used to login to the database.
          * `<pwd>` is not used in SQLite. For !PostGres, this is the password for the user.
          * `<host>` is not used in SQLite. For !PostGres, this is the IP address the database engine is hosted on.
        * `<sqlQCUpdateFile>` the full path to the SQL file the scripts creates upon execution. A sample SQL line is: "UPDATE multi_obs SET qc_flag='222200',qc_level=3 WHERE m_date='2009-03-23T01:36:00' AND sensor_id=4099"
     * `<qcLimits>`
       * `<fileType>` defines the format the range limits are stored in. Currently the only valid entry is test_profiles. The idea behind this setting is to allow different sources for the range limits, perhaps in a database or spreadsheet. 
       * `<file>` is the full filepath to the limits file. Current used is the test_profiles.xml type file.
     * `<unitsCoversion>`
       * `<file>` full filepath to the xml file that contains the units conversion formulas used.
     * `<logging>` 
       This section defines various logging parameters.
       * `<logMsgs>` flag, 0 or 1, to specify whether or not to log to file. 
       * `<maxBytes>` the size a log file is allowed to grow until it is closed and a new one begun.
       * `<backupCount>` the number of backup log files to keep. A backup file is created each time its size exceeds the amount in `<maxBytes>`.
       * `<logDir>` the path to store the log files in.
     * `<outputs>`
     Deals with the various outputs from the script.
       * `<qcResultsTable>` the path to an HTML file which shows the results, grouped by platform, of the range tests. A live example can be found [http://129.252.37.90/xenia/feeds/qaqc/test_results.html here]. Each platform row will have a column for a measurement tested, defined in the test_profiles.xml file. 
 
   * test_profiles.xml
   The following is an example of a simple test_profiles.xml file which contains only one platform with one sensor for QC validation:
 {{{
 <xml>
  <testProfileList>
   <testProfile>
    <id>CaroCoopsBuoys</id>
    <platformList>
     <platform>carocoops.CAP3.buoy</platform>
    </platformList>
    <obsList>
     <obs>
      <obsHandle>wind_speed.m_s-1</obsHandle>
      <UpdateInterval>24</UpdateInterval>
      <rangeHigh>32565</rangeHigh>
      <rangeLow>-32565</rangeLow>
      <grossRangeHigh>30</grossRangeHigh>
      <grossRangeLo>0</grossRangeLo>
      <climatologicalRangeList> 
        <climateRange>
          <startMonth>Jan</startMonth>
          <endMonth>Mar</endMonth>
          <rangeLow>30</rangeLow>
          <rangeHigh>27</rangeHigh>
        </climateRange>  
      </climatologicalRangeList>
     </obs>
    </obsList>
    <notify>
     <timeLagLimit>14400</timeLagLimit>
     <wait>10</wait>
     <emailGroup>1</emailGroup>
     <emailMessage>5</emailMessage>
    </notify>
   </testProfile>
  </testProfileList>
 </xml>
 }}}


  A file may contain multiple test profiles, each of which can be used to group like platforms together. Like platforms would be platforms that have
  the same sensor array on board. 
  * `<testProfileList>`
  This tag denotes the start of a list of one or more `<testProfile>` entries.
  * `<testProfile>`
    * `<id>` 
    Names the test profile grouping that follows.
    * `<platformList>`
    The `<platformList>` can contain one or more `<platform>` child tags which provide the name of the platform to be tested in the `<testProfile>`. 
    * `<obsList>`
    Begins the list of each observation type the `<testProfile>` will run data range checks on.
      * `<obs>` is the starting tag for an individual observation type definition. 
        * `<obsHandle>` defines the observation type. The format for an `<obsHandle>` entry is "sensor name.unit of measurement", for example: "air_temperature.farenheit".   The sensor name must be defined in the databases sensor table. The unit of measurement must be defined in the uom_type table. 
        * `<UpdateInterval>` defines how many times a day a sensor transmits its data from the platform to the outside world. The sample above shows an interval of 24, which would be every hour. This could be considered more of a platform configuration.
        * `<rangeHigh>` defines the upper acceptable range of a sensor. This is given as a floating point number.
        * `<rangeLow>` defines the lower acceptable range of a sensor. This is given as a floating point number.
        * `<grossRangeHigh>` defines the upper range the measurement the sensor makes can be.
        * `<grossRangeLo>` defines the lower range the measurement the sensor makes can be.
        * `<climatologicalRangeList>`
        Begins a section defining climatological ranges. Can have up to 12, 1 per month. 
          * `<climateRange>`
          Section will contain a range limit over a given month timeperiod.
            * `<startMonth>` the month, abbreviate unix style, the range begins on.
            * `<endMonth>` the month, abbreviate unix style, the range ends on.
            * `<rangeLow>` the low climatological test range.
            * `<rangeHigh>` the high climatological test range.

        * `<timeLagLimit>` tag sets the number of seconds deviation allowed from the current time of the system compared to the measurement time in the database before the data is flagged as lagging.

  === Output ===
  * Database
    * From the configuration file, we defined `<sqlQCUpdateFile>` which contains the SQL UPDATES to run against the database to set the values for the qc_level and qc_flag columns in the multi_obs table.
      * qc_flag
      This is interpreted as follows. The leftmost byte is the first test, which is the data available test, each preceeding byte is another test of lesser importance. We store the values in a string which is to always contain the same number of bytes for consistency. The flags from left to right: Data available, sensor range check, gross range check, climate range check, rate of change, nearest neighbor. Currently rate of change and nearest neighbor are not implemented.
      Some examples:
{{{
          "000000" would represent no tests were done
          "200000" represents the data available test was done and passed(0 = no test, 1 = failed, 2 = passed)
          "220000" data available, sensor range tests performed.
}}}